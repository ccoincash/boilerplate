import "util.scrypt";

/**
 * A token protocol based on UTXO model
 */
contract Token {
    public function split(Sig senderSig, PubKey receiver0, int tokenAmount0, int satoshiAmount0, PubKey receiver1, 
            int tokenAmount1, int satoshiAmount1, Ripemd160 changePKH, int changeSatoshis, bytes txPreimage) {
        require(tokenAmount0 > 0);
        // 1 to 1 transfer when tokenAmount1 is 0
        require(tokenAmount1 >= 0);

        // The following arguments can be generated using sample code at
        // https://gist.github.com/scrypt-sv/f6882be580780a88984cee75dd1564c4.js
        PrivKey privKey = PrivKey(0x621de38d9af72be8585d19584e3954d3fd0dc9752bb9f9fb28c4f9ed7c1e40ea);
		PubKey pubKey = PubKey(b'02773aca113a3217b67a95d5b78b69bb6386ed443ea5decf0ba92c00d179291921');
        // invK is the modular inverse of k, the ephemeral key
		int invK = 0xa2103f96554aba49bbf581738d3b5a38c5a44b6238ffb54cfcca65b8c87ddc08;
        // r is x coordinate of R, which is kG
		int r = 0x00f0fc43da25095812fcddde7d7cd353990c62b078e1493dc603961af25dfc6b60;
        // rBigEndian is the signed magnitude representation of r, in big endian
		bytes rBigEndian = b'00f0fc43da25095812fcddde7d7cd353990c62b078e1493dc603961af25dfc6b60';
        
        SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
        // this ensures the preimage is for the current tx
		require(Tx.checkPreimageAdvanced(txPreimage, privKey, pubKey, invK, r, rBigEndian, sigHashType));

        // read previous locking script
        // locking script = codePart + OP_RETURN + senderPublicKey + balance0 + balance1
        bytes lockingScript = Util.scriptCode(txPreimage);
        int scriptLen = length(lockingScript);

        int amountStart = scriptLen - Util.DataLen * 2;

        PubKey sender = PubKey(lockingScript[amountStart - Util.PubKeyLen : amountStart]);
        // authorize
        require(checkSig(senderSig, sender));
        
        int balance0 = unpack(lockingScript[amountStart : amountStart + Util.DataLen]);
        int balance1 = unpack(lockingScript[amountStart + Util.DataLen :]);

        // split
        require(balance0 + balance1 == tokenAmount0 + tokenAmount1);
        
        // persist contract code part, including op_return itself
        bytes codePart = lockingScript[: amountStart - Util.PubKeyLen];
        
        // setting first balance as 0 is just a convention, not a requirement
        bytes outputScript0 = codePart + receiver0 + num2bin(0, Util.DataLen) + num2bin(tokenAmount0, Util.DataLen);
        bytes output0 = num2bin(satoshiAmount0, Util.OutputValueLen) + Util.writeVarint(outputScript0);
        bytes output1 = b'';
        if (tokenAmount1 > 0) {
            bytes outputScript1 = codePart + receiver1 + num2bin(0, Util.DataLen) + num2bin(tokenAmount1, Util.DataLen);
            output1 = num2bin(satoshiAmount1, Util.OutputValueLen) + Util.writeVarint(outputScript1);
        }

        // change output
		bytes changeScript = Util.buildPublicKeyHashScript(changePKH);
		bytes changeOutput = num2bin(changeSatoshis, Util.OutputValueLen) + Util.writeVarint(changeScript);

		Sha256 hashOutputs = hash256(output0 + output1 + changeOutput);
        require(hashOutputs == Util.hashOutputs(txPreimage));
    }

    public function merge(Sig senderSig, PubKey receiver, bool isFirstInput, int otherTokenAmount, int satoshiAmount,
                            Ripemd160 changePKH, int changeSatoshis, bytes txPreimage) {
        require(otherTokenAmount >= 0);

        PrivKey privKey = PrivKey(0x621de38d9af72be8585d19584e3954d3fd0dc9752bb9f9fb28c4f9ed7c1e40ea);
		PubKey pubKey = PubKey(b'02773aca113a3217b67a95d5b78b69bb6386ed443ea5decf0ba92c00d179291921');
        // invK is the modular inverse of k, the ephemeral key
		int invK = 0xa2103f96554aba49bbf581738d3b5a38c5a44b6238ffb54cfcca65b8c87ddc08;
        // r is x coordinate of R, which is kG
		int r = 0x00f0fc43da25095812fcddde7d7cd353990c62b078e1493dc603961af25dfc6b60;
        // rBigEndian is the signed magnitude representation of r, in big endian
		bytes rBigEndian = b'00f0fc43da25095812fcddde7d7cd353990c62b078e1493dc603961af25dfc6b60';
        
        SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
        // this ensures the preimage is for the current tx
		require(Tx.checkPreimageAdvanced(txPreimage, privKey, pubKey, invK, r, rBigEndian, sigHashType));

        // read previous locking script
        bytes lockingScript = Util.scriptCode(txPreimage);
        int scriptLen = length(lockingScript);

        int amountStart = scriptLen - Util.DataLen * 2;

        PubKey sender = PubKey(lockingScript[amountStart - Util.PubKeyLen : amountStart]);
        // authorize
        require(checkSig(senderSig, sender));

        int balance0 = unpack(lockingScript[amountStart : amountStart + Util.DataLen]);
        int balance1 = unpack(lockingScript[amountStart + Util.DataLen :]);

        // persist contract code part, including op_return itself
        bytes codePart = lockingScript[: amountStart - Util.PubKeyLen];
        
        bytes amountPart = b'';
        if (isFirstInput) {
            amountPart = num2bin(balance0 + balance1, Util.DataLen) + num2bin(otherTokenAmount, Util.DataLen);
        } else {
            amountPart = num2bin(otherTokenAmount, Util.DataLen) + num2bin(balance0 + balance1, Util.DataLen);
        }
        // merge output
        bytes mergeScript = codePart + receiver + amountPart;
        bytes mergeOutput = num2bin(satoshiAmount, Util.OutputValueLen) + Util.writeVarint(mergeScript);
        // change output
		bytes changeScript = Util.buildPublicKeyHashScript(changePKH);
		bytes changeOutput = num2bin(changeSatoshis, Util.OutputValueLen) + Util.writeVarint(changeScript);

		Sha256 hashOutputs = hash256(mergeOutput + changeOutput);
        require(hashOutputs == Util.hashOutputs(txPreimage));
    }
}